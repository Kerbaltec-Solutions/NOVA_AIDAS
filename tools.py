import json
import shutil
import time
import subprocess
import builtins
import urllib.parse
import urllib.request
import pyautogui
from tkinter.messagebox import askyesno
import serpapi
import ollama 
import spinner 
import text_tools
import settings

if settings.SERP_KEY!="":
    serp = serpapi.Client(api_key=settings.SERP_KEY)

def get_tools():
    if settings.SERP_KEY!="":
        return [CONSOLE_TOOL,WIKI_TOOL,WEB_TOOL,TEXT_TOOL]
    return [CONSOLE_TOOL,WIKI_TOOL,TEXT_TOOL]

def get_function_by_name(fn_name):
    if(fn_name=="run_console_command"):
        return run_console_command
    elif(fn_name=="fetch_wikipedia_content"):
        return fetch_wikipedia_content
    elif(fn_name=="fetch_website"):
        return fetch_website
    elif(fn_name=="type_text"):
        return type_text

CONSOLE_TOOL = {
    "type": "function",
    "function": {
        "name": "run_console_command",
        "description": (
            "Run a command generated by you in the linux console. "
            "Always use this if the user is asking for an action, that you normally cannot perform. "
            "Never use this to access information from the internet or wikipedia. "
            "If the result is an error, correct the command and try again."
        ),
        "parameters": {
            "type": "object",
            "properties": {
                "command": {
                    "type": "string",
                    "description": "The linux console command, you want to execute",
                },
            },
            "required": ["command"],
        },
    },
}

WIKI_TOOL = {
    "type": "function",
    "function": {
        "name": "fetch_wikipedia_content",
        "description": (
            "Search Wikipedia and fetch the introduction of the most relevant article. "
            "Always use this if the user is asking for information that is likely on wikipedia. "
            "If the user has a typo in their search query, correct it before searching."
        ),
        "parameters": {
            "type": "object",
            "properties": {
                "search_query": {
                    "type": "string",
                    "description": "Search query for finding the Wikipedia article",
                },
            },
            "required": ["search_query"],
        },
    },
}

WEB_TOOL = {
    "type": "function",
    "function": {
        "name": "fetch_website",
        "description": (
            "Returns the text content of the first website for a given search query. "
            "Always use this if the user is asking for information that is likely on websites other than wikipedia. "
            "If the user has a typo in their search query, correct it before searching."
        ),
        "parameters": {
            "type": "object",
            "properties": {
                "query": {
                    "type": "string",
                    "description": "The search query to get information about",
                },
            },
            "required": ["query"],
        },
    },
}

TEXT_TOOL = {
    "type": "function",
    "function": {
        "name": "type_text",
        "description": (
            "Controls the users keyboard to type a provided text into a text field. "
            "Use this functin, if the user asks you to type down or write down a text. "
        ),
        "parameters": {
            "type": "object",
            "properties": {
                "text": {
                    "type": "string",
                    "description": "The text to type",
                },
            },
            "required": ["text"],
        },
    },
}

def run_console_command(command: str) -> dict:
    command=command.replace('\\n', '\n').replace('\\t', '\t').replace('\\','')
    terminal_width = shutil.get_terminal_size().columns
    builtins.print("\n" + "=" * terminal_width+"\n")
    time.sleep(1)
    e=-2
    while(e==-2):
        messages_eval = [
            {
                "role": "system",
                "content": (
                    "You are an assistant that interprets linux console commands. "
                    "When prompted with a command, state accurately and truthfully, what that command does. "
                    "Keep your response brief but include all relevant information. "
                ),
            }
        ]
        messages_eval.append({"role": "user", "content": command})
        with spinner.Spinner("Interpreting..."):
            with spinner.Spinner("Thinking..."):
            #text = tokenizer.apply_chat_template(messages_a, tools=tools, add_generation_prompt=True, tokenize=False)
                response = ollama.chat(
                    model= settings.LLM_MODEL,
                    messages= messages_eval,
                    keep_alive= 0,
                )
        if askyesno("Confirm command execution", command+"\n\n"+response.message.content):
            e=1
        else:
            e=0       
    if(e==1):
        print("Executing command: "+command+"\n")
        p = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
        output, error = p.communicate()
        if p.returncode != 0:
            builtins.print("\n"+"-" * terminal_width+"\n")
            print("Error calling command: "+error.decode())
            builtins.print("=" * terminal_width + "\n")
            return {
                "command": command, "output": error.decode(), "status": "failed"
            }
        else:
            builtins.print("\n"+"-" * terminal_width+"\n")
            if(output.decode()=="" and error.decode()!=""):
                builtins.print(error.decode())
            else:
                builtins.print(output.decode())
            builtins.print("=" * terminal_width + "\n")
            if(output.decode()=="" and error.decode()!=""):
                return {"command": command, "output": error.decode(), "status": "error"}
            else:
                return {"command": command, "output": output.decode(), "status": "success"}
    elif(e==0):
        builtins.print("\n"+"-" * terminal_width+"\n")
        print("Command denied by user")
        builtins.print("=" * terminal_width + "\n")
        return {
            "command": command, "output": "command denied by user", "status": "denied"
        }

def fetch_wikipedia_content(search_query: str) -> dict:
    """Fetches wikipedia content for a given search_query"""
    print("Fetching wikipedia content for "+search_query)
    try:
        # Search for most relevant article
        search_url = "https://en.wikipedia.org/w/api.php"
        search_params = {
            "action": "query",
            "format": "json",
            "list": "search",
            "srsearch": search_query,
            "srlimit": 1,
        }

        url = f"{search_url}?{urllib.parse.urlencode(search_params)}"
        with urllib.request.urlopen(url) as response:
            search_data = json.loads(response.read().decode())

        if not search_data["query"]["search"]:
            return {
                "status": "error",
                "message": f"No Wikipedia article found for '{search_query}'",
            }

        # Get the normalized title from search results
        normalized_title = search_data["query"]["search"][0]["title"]

        # Now fetch the actual content with the normalized title
        content_params = {
            "action": "query",
            "format": "json",
            "titles": normalized_title,
            "prop": "extracts",
            "exintro": "true",
            "explaintext": "true",
            "redirects": 1,
        }

        url = f"{search_url}?{urllib.parse.urlencode(content_params)}"
        with urllib.request.urlopen(url) as response:
            data = json.loads(response.read().decode())

        pages = data["query"]["pages"]
        page_id = list(pages.keys())[0]

        if page_id == "-1":
            return {
                "status": "error",
                "message": f"No Wikipempg123 /usr/share/sounds/ubuntu/stereo/positive-acknowledge.wavdia article found for '{search_query}'",
            }

        content = pages[page_id]["extract"].strip()
        return {
            "status": "success",
            "content": content,
            "title": pages[page_id]["title"],
        }

    except Exception as e:
        return {"status": "error", "message": str(e)}

def fetch_website(query:str) -> dict:
    print("Getting page for "+query)

    results=serp.search(q=query, engine="google", hl="en", gl="us")["organic_results"]
    for result in results:
        url = result["link"]
        try:
            fp = urllib.request.urlopen(url.replace(" ","_"))
            mybytes = fp.read()
            page_source = mybytes.decode("utf8")
            head=text_tools.get_between(page_source,"<title>","</title>")
            body=text_tools.get_between(page_source,"<body>","</body>")
            body=text_tools.unempty(body)
            body=body.replace('\\"','~dnr~')
            body=body.replace('</tr>','~nl~')
            body=body.replace('<br>','~nl~')
            body=text_tools.remove_between(body,'<{"','}>"')
            body=body.replace('~dnr~','"')
            body=' '.join(body.split())
            body=body.replace('.','.\n')
            body=text_tools.unempty(body)
            with open("./source.html","w") as f:
                f.write("Head:\n")
                f.write(head)
                f.write("\nBody\n")
                f.write(body)
            
            resp={"status": "success","query": query, "page_url": url, "page_title": head, "page_body": body}
            
            return (resp)
        except Exception as e:
            # Close the WebDriver
            print(e)
    return {"status": "error", "message": "no matching webpages were found"}
        
def type_text(text:str) -> dict:

    print("Typing: "+text)
    
    pyautogui.typewrite(text)

    resp={"status": "success"}
    return (resp)